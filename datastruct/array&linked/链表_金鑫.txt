链表
概念：链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列节点组成，每个节点一般至少包含两部分信息：一部分是元素数据本身，另一部分是指向下一个元素地址的指针。
类型：单向链表、双向链表（每个节点除了存储元素数据本身外还额外存储两个指针，分别指向上一个节点和下一个节点的地址）、循环链表(最后一个结点的指针域指向头结点，整个链表形成一个环)

操作：创建、插入、删除、输出

插入：头插入、尾插入、中间插入
头插入:增加一个新的节点，然后把新增加的节点的指针指向原来头指针指向的元素，再把头指针指向新增的节点。时间复杂度O(1)
尾插入:增加一个新的节点，然后把原尾指针指向节点的指针指向新增加的节点，最后把尾指针指向新增加的节点。时间复杂度O(1)
中间插入:增加一个新的节点，然后把新增加节点的指针指向插入位置的后一个位置的节点，把插入位置的前一个节点的指针指向新增加的节点。时间复杂度O(L)，L为插入下标

删除：头删除，尾删除，中间删除
头删除：先把头指针指向下一个节点，然后把原头节点的指针置空。时间复杂度O(1)
尾删除：找到链表的倒数第二个元素，把尾指针指向这个元素，然后把原倒数第二个元素的尾指针置空。时间复杂度O(N)N为链表长度
中间删除：首先把要删除的节点的之前一个节点的指针指向要删除的节点的下一个节点，接着把要删除节点的指针置空。时间复杂度O(L)

特点：
1.物理空间不连续，空间开销更大（优点：可以利用操作系统的动态内存管理 缺点：需要更多的存储空间存储指针信息）。
2.运行时可以动态添加（不会出现像数组空间不够用的情况）
3.查找元素需要顺序查找（查找元素时，需要逐个遍历往后查找元素）
4.操作稍显复杂（增加删除元素时，不但需要处理数据还需要处理指针）

适用场景：
一般会优先使用双向链表，双向链表不管从头找还是从尾找，操作是一样的，因此对尾数据进行操作时不用逐个从头遍历，可以直接从尾向前查找元素。
可以动态添加元素，弥补了使用数组空间不足的缺陷。
一般的程序可能会使用一个简单的消息队列进行消息缓冲，而队列只能从头，尾，进行，所以使用链表（双向链表）就非常方便了。

反转链表的方法：
可以依次遍历链表，然后依次使用头插入的方法。
反转指针。

/**
*反转链表
*/
public void reverse(){
	Node temp = first;
	last = temp;
	Node next = first.getNext();
	for(int i = 0;i<size-1; i++){
		Node nextNext = next.getNext();//下下个
		next.setNext(temp);
		temp = next;
		next = nextNext;
	}
	last.setNext(null);
	first = temp;
}


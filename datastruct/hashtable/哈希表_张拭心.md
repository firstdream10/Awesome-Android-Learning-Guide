2018年4月17日星期二

在某种程度上，散列是与排序相反的一种操作，排序是将集合中的元素按照某种方式比如字典顺序排列在一起，而散列通过计算哈希值，打破元素之间原有的关系，使集合中的元素按照散列函数的分类进行排列。



在介绍一些集合时，我们总强调需要重写某个类的 equlas() 方法和 hashCode() 方法，确保唯一性。这里的 hashCode() 表示的是对当前对象的唯一标示。计算 hashCode 的过程就称作 哈希。



哈希 其实是随机存储的一种优化，先进行分类，然后查找时按照这个对象的分类去找。哈希通过一次计算大幅度缩小查找范围，自然比从全部数据里查找速度要快。



比如你和我一样是个剁手族买书狂，家里书一大堆，如果书存放时不分类直接摆到书架上（数组存储），找某本书时可能需要脑袋从左往右从上往下转好几圈才能发现；如果存放时按照类别分开放，技术书、小说、文学等等分开（按照某种哈希函数计算），找书时只要从它对应的分类里找，自然省事多了。



**上面文字摘自我之前写的：[重温数据结构：哈希 哈希函数 哈希表](https://blog.csdn.net/u011240877/article/details/52940469)**，在那篇文章里探讨了这么几点：

1. 什么是哈希
2. 为什么要有哈希
3. 几种哈希函数
4. 哈希冲突的解决
5. 哈希表

这里再谈谈哈希表的使用场景。

# 哈希表的使用场景

前面提到，哈希表是非线性的，插入元素时根据哈希函数决定要保存的位置，在获取时根据哈希函数即可得到位置，除去哈希冲突的特殊情况，一般花费 O(1) 的时间复杂度即可拿到数据。

鉴于哈希表的快速获取特性，我们可以在下面的场景里使用它：

1. 内存缓存
 - 缓存的存在是为了提高效率，使用哈希表来实现缓存，不仅可以省去重新生成的时间，还可以加快查询的效率，一举两得
2. 快速查找
 - 有时候需要在一大堆数据里找到某个数据，你有很多种算法比如二分、比如先排序，但那都依赖于数据有序，在数据无序的情况下，适用哈希表来保存，查询时的效率可以说是非常快的
3. 建立关联关系
 - 哈希表的核心就是 key-value，这正适合一些需要建立关联的业务中，比如 EventBus 中就使用了哈希表保存了事件和调用方法的映射关系

# 哈希表的性能

哈希表是一种用空间换时间的存储结构，一般用于提升时间效率，但要注意占用的空间不要太多。

哈希表的每个节点除了保存 key-value，可能还需要保存一个其他节点的引用（如果使用拉链法解决冲突的话），这使得它占用的空间更加大了。

在内存敏感的环境里（比如手机），如果保存的数据允许部分丢失（比如缓存），可以建立一个最大数量限制，在超出最大数量后删除部分元素（删除算法可以使用 LRU），这样可以避免过度使用内存。

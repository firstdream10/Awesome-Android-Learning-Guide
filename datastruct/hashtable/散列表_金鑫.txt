散列表

一：概念：
又叫哈希表(Hash Table),是能够通过给定的关键字的值直接访问到具体对应的值的数据结构。也就是说，把关键字映射到一个表中的位置来直接访问记录，以加快访问速度。
通常把这个关键字称为Key，把对应的记录称为Value，所以也可以说是通过Key访问到映射表来得到Value地址。而这个映射表也叫做散列函数或者哈希函数。存放记录的数组叫做散列表。
有种特殊情况是通过不同的Key，可能访问到同一个地址，即key1≠key2，而f(key1)=f(key2)，这种现象叫做碰撞。而通过某个Key一定会得到唯一的Value地址。

哈希算法，是一类算法；

哈希表（Hash Table）是一种数据结构；

哈希函数，是支撑哈希表的一类函数；

Map是映射、地图的意思，在Java中Map表示一种把K映射到V的数据类型；

HashMap是Java中用哈希数据结构实现的Map；


二：哈希函数实现方法需要考虑的因素
关键字的长度、哈希表的大小、关键字的分布情况、记录的查找频率等等。
1.直接寻址法
取关键字或关键字的某个线性函数值为散列地址。

2.数字分析法
通过对数字的分析，发现数据中冲突较少的部分，并构造散列地址。

3.平方取中法
当无法确定关键字里哪几位分布相对比较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为散列地址。这是因为计算平方之后的中间几位和关键字中的每一位都相关，所以不同的关键字会以较高的概率产生不同的散列地址。

4.取随机数法
使用一个随机函数，取关键字的随机值作为散列地址，这种方式通常用于关键字长度不同的场合。

5.除留取余法
取关键字被某个不大于散列表的表长n的数m除后所得余数p为散列地址。这种方式可以在用过其他方法之后再使用，该函数对m的选择很重要，一般取素数或直接用n。

6.折叠法
将关键字分割成位数相同的几部分，最后一部分位数可以不同，然后取这几部分的叠加和（去除进位）作为散列地址。数位叠加可以有移位叠加和间界叠加两种方法。移位叠加是将分割后的每一部分的最低位对齐，然后相加；间界叠加是从一端向另一端沿分割界来回折叠，然后对齐相加。

常用的hash算法：
（1)MD4 (2)MD5 （3)SHA-1及其他

哈希函数的应用：
错误校正、语音识别、信息安全（文件校验、数字签名、鉴权协议）

三：对散列表函数产生冲突的解决办法
为什么会产生冲突：哈希函数有时对不同的Key计算之后获得了相同的地址。
处理方式：
1.开放地址法（也叫开放寻址法）
当需要存储值时，对key哈希之后，发现这个地址已经有值了，这时不能放在这个地址，不然之前的映射会被覆盖。这时要对计算出来的地址进行一个探测再哈希，比如往后移动一个地址，如果没人占用，就用这个地址。如果超过最大长度，则可以对总长度取余。这里移动的地址是产生冲突时的增列序量。

2.再哈希法
在产生冲突之后，使用关键字的其他部分继续地址计算，如果还有冲突，则继续使用其他部分再计算地址。（这种方式的缺点是时间增加了）

3，链地址法
对Key通过哈希之后落在同一个地址上的值，做一个链表。

4.建立一个公共溢出区
当地址存在冲突时，把新的地址放在公共溢出区里。


散列表的存储结构:在大多数时候，我们通过数组定义散列表。


四：散列表的特点
两种用法：一种是Key的值和value的值一样，一般称这种结构为set(集合)；而如果key和Value所对应的值不一样时，称这种情况为Map，也就是键值对集合。

特点：
1.访问速度很快
由于散列表有散列函数，可以将制定的Key都映射到一个地址上，所以在访问一个Key对应的Value值时，根本不需要一个一个的查找，可以直接跳到那个地址。所以在对散列表进行添加、删除、修改、查找等任何操作时，速度都很快。

2.需要额外的空间
散列表实际是存不满的，如果刚好存满那肯定是巧合。而且当散列表的元素使用率越来越高时，性能会下降，所以一般选择扩容来解决这个问题。如果有冲突的话，也需要使用额外的空间去存储，比如链地址法。这个特点有个很常用的特点，叫做“空间换时间”。

3.无序
为了能够更快的访问元素，散列表是根据散列函数直接找到存储地址的，所以访问速度会很快。

4.可能会产生碰撞
这时需要使用冲突的解决方案。


五：适用场景
根据特点可以想到，散列表比较适合无序、需要快速访问的情况。
1.缓存
在开发中通常会对一些常用的信息做缓存，用的就是散列表。
2.快速查找
在集合中找出是否存在指定的元素。

六：性能分析
散列表的访问，如果没有碰撞，那么可以认为对元素的访问是O(1)的时间复杂度，因为对于任何元素的访问都可以通过散列函数直接得到元素的值所在的地址。
实际上不可能没有碰撞，所以不得不对碰撞做一定的处理。
常用链表方式解决，由于可能产生碰撞，而碰撞之后的访问需要遍历链表，所以时间复杂度将变为O(L),L为链表的长度。
还有一种情况就是有可能分配的地址即散列表的元素大部分被使用了，这时再向散列表添加元素就很容易发生碰撞，散列表分配的地址越在后面使用，越容易被占用(解决方法：扩容)。
在散列表的使用过程中，不会等到把所有的地址都使用完了才去扩容，而是会在占用地址达到散列表长度乘以扩容因子这个值时去扩容，一般的扩容会在原来长度的基础上乘以2作为新的长度。在java中，扩容因子默认为0.75。

七：缺点
哈希表也有一些缺点它是基于数组的，数组创建后难于扩展某些哈希表被基本填满时，性能下降得非常严重，所以程序虽必须要清楚表中将要存储多少数据（或者准备好定期地把数据转移到更大的哈希表中，这是个费时的过程）。

面试题：
题目：海量日志数据，提取出某日访问百度次数最多的那个IP。
方案：IP的数目还是有限的，最多2^32个，所以可以考虑使用hash将ip直接存入内存，然后进行统计。




















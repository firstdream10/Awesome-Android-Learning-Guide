
# Q：创建一个类的时候，什么时候选择类、内部类、静态内部类、匿名内部类？设计框架时该如何选择。

根据单一职能原则，一般情况下，一个小功能的实现，就需要创建一个类。

内部类一般不需要提供对外访问，因此一般针对某一个类的功能进行 扩展/抽取 的时候，可以考虑使用内部类，可以解决 Java 不能多继承的问题，并且内部类和宿主类之间具有高内聚性。

静态内部类的生命周期会随着宿主类的加载而加载，而不是随着对象的产生而产生。静态内部类中不能访问宿主类的非静态成员。一般内部类是强绑定在宿主类上的，静态内部类则不用。

# Q：什么时候会创建一个抽象类，为什么不用接口？设计框架时该如何选择？

其实这个问题，我觉得质押分清类和接口的区别即可，类是一个对象，定义一个对象的属性；接口是一种行为扩展及规范，使某个类具有某种特定的行为。

理解了这个区别，这个问题就很好回到了。比如说我们要设计一个“动物架构”，首先创建 Animal 抽象类，因为动物本来就是一个抽象名词，代指一类生物。这一类生物都具有哪些共性呢?一般都会呼吸、吃、排泄等基本生命活动，但是不同的动物吃的食物、呼吸的方式（鱼在水里）、排泄等行为都是不一样的，所以 Animal 具有呼吸、吃、排泄等抽象方法，但是所有的动物都有年龄和出手时间，所以 Animal 具有年龄和出手时间两条属性。

然后我们来说接口，动物可以分为天上飞的、水里游的、地上跑的。所以可以分类鸟、爬行动物、鱼三种类型，这三种类型都有自己的共性。比如说猫头鹰鸟属于动物，但是又属于鸟类会飞，所以需要定义一个 Bird 接口，鸟最大的特征就是会飞，所以 Bird 接口具有 fly 方法。

# 常见的类、成员变量修饰符
protected、private、public 是权限修饰符，这个没什么好讲的，根据是否需要对外提供访问选择 public 、是否能够给子类调用选择 proteted 及以上、是否只能自己和内部类用选择 privae 即可。
final 修饰方法不能不子类重写、修饰变量不能被第二次赋值。
static 修饰内部类上文说了；修饰方法和成员变量不需要依赖对象而存在，直接类名.**即可；static 修饰是随着类的的加载而加载的。

transient 这是一个程度较轻的synchronized，用于修饰变量，一般用于多并发。这个有点难讲清。我举个简单的例子

	long i = 0；
	i++；
在 i++的过程计算机内部做了三件事，分别是读取-修改-写入。然后问题来了，在读取的过程中，由于多线程操作，线程的执行权换了，另一个线程对 i 进行了赋值操作。transient 的存在就是避免出现这样的事情的。

四中引用类型：强引用、软引用、弱引用、虚引用。这个我也不弄清楚，就跳过吧。

# 自动装箱拆箱
基本数据类型和封装数据类型互相替换的时候，Java 会进行自动装拆箱的操作。我举个例子吧。

	public int test(Integer i){
		return i+5;
	}
如果我调用 test(2);首先把2传递给方法参数会执行一次装箱操作，然后 i+5又会执行一次拆箱操作，拆装箱操作对性能肯定是会有影响的。
注意：如果我调用 test(null);在编译的时候不会报错，但是运行的时候肯定会报错的，大概是报 NullPointException吧，在拆箱的过程中发现i 是空指针。

# 注解
不知道

# 反射
反射就是损耗一定的性能、越过修饰符权限去访问原本没有权限访问的变量和方法。

# 泛型
在不确定引用类型的情况下，可以使用泛型来代替。
一般 Base** 的地方会使用泛型。
另外，集合里面的数据类型都是泛型。

# 异常
异常都继承自 Throwable。按照继承关系分为 Error 和 Exception，Error 是程序无法处理的异常，一般为 JVM 层面的问题；Exception 异常是可以通过代码处理的，处理方式有两种try...catch 和 throw,Exception 分为运行时异常和编译时异常,其中运行时异常可以不用处理，但编译时异常必须 try...catch或者 throw.

try...catch...finally 语句处理流程：一旦某个catch捕获到匹配的异常类型，将进入异常处理代码。一经处理结束，就意味着整个try-catch语句结束。其他的catch子句不再有匹配和捕获异常类型的机会，并且 try 里面如果有没有走完的语句也会自动跳过。如果有 finally 语句则最后执行 finally 语句，如果在 finally 之前执行了 return 语句，则在方法 return 之前会优先执行 finally。


# 集合框架
List：有序可重复的元素集合。常用 ArrayList 和 LinkedArrayList，前者是基于数组做的实现，查找快，增删慢，后者基于链表实现，查找慢，增删快，都是不同步。Vector功能和 ArrayList 差不多，但是同步。
Set：不包含重复元素的集合，常见 HashSet 和 TreeSet，分别基于 HashMap 和 TreeMap 做的实现。
Map：键值对形式的集合，又称 Dictionary（JDK1.2的键值对实现）。常用 HashMap 和 TreeMap，分别基于散列表、红黑树算法。


# IO
分字符流和字节流，如果按读写方式分读取流和写入流。
其中字节流的基类分是 InputStream 和 OutputStream，字符流是 Reader 和 Writer。其中字符流是基于字节流做的实现，本质是一次读取两个字节，并且其中的字节转字符用到了转换流 InputStreamReader和 OutputStreamWriter。
为了提高读写效率，引入了缓冲流的概念，缓冲流其实就是一个包装类，一次预先读写很多数据，避免文件的频繁读写操作。
使用场景：除了文字、字符意外的文件，都使用字节流。


# 字符串
String 为什么不可变？不知道。
StringBuffer 和 StringBuilder 就是同步和不同步的区别，同步的性能差一点。

# 枚举
能过罗列出所有状态的情况，推荐使用枚举，枚举可以规范代码的输入，在编译时避免因输入错误而引发运行时异常。

# 工具类 Collections、Arrays
Collections：针对集合的工具类，若干操作集合的方法。
Arrays：针对数组的工具类，若干操作数组的方法。



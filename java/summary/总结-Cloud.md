#### 创建一个类的时候，什么时候选择类、内部类、静态内部类、匿名内部类？设计框架时该如何选择？

答：我们默认使用的就是普通类，而在下面几种情况使用内部类
1.完全禁止其他人依赖类型编码，并可将具体的实现细节完全隐藏，这种情况可以使用private修饰的内部类
2.如果想让内部类不依附于外部类而存在，那就可以使用静态内部类，那这个内部类可以不需要通过外部类的对象来创建
3.定义回调决口的时候可以使用匿名内部类，如Android中button的点击事件
`mButton1.setOnClickListener(new View.OnClickListener() {}`

#### 什么时候会创建一个抽象类，为什么不用接口？设计框架时该如何选择？

接口可以理解为更“纯”的抽象类，它的出现弥补了，java只支持单继承的缺陷。使用接口的同时也可以获得抽象类的好处。所以假如想创建的基础类没有任何方法定义或者成员变量，那么无论如何都愿意使用接口，而不要选择抽象类。只有在必须使用方法定义和成员变量的时候才使用抽象类

#### 类的成员变量修饰符有哪些？protected private 怎么选，什么时候用 final 修饰，什么时候会用 static ？

- 共有4种成员变量修饰符 public、protected、缺省（default）、private。
- 如果只想在同一包内和子孙类使用使用protected修饰符，只想在当前类使用时，使用private修饰符。
- 当我们想让一个类不可被继承时或出于安全的考虑可以用final来修饰，如果想定义一个基本数据类型的变量，则其数值一旦在初始化之后便不能更改可以用final来修饰；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象可以用final来修饰。

#### 什么时候会发生自动装箱拆箱？有什么需要注意的吗？对性能有什么影响？
自动装箱就是将原始类型自动的转换为对应的对象，而拆箱就是将对象类型转换为基本类型。java中的自动拆装箱通常发生在变量赋值的过程中
基本数据类型---->包装类：自动装箱   Integer i = 10;
包装类------>基本数据类型:自动拆箱   int j = i;

需要注意，在使用自动装箱成包装类对象时，如果想要比较这两个值是否相等不能使用 == 来比较，要使用equals()

性能影响：在java中，应该注意自动拆装箱，因为有时可能因为java自动装箱机制，而导致创建了许多对象，对于内存小的平台会造成压力。

#### 注解是什么？有几种类型？分别的使用场景？
注解（Annotation）一种代码级别的说明，也叫元数据。。
作用分类：
1.生成文档（doc注释生成doc文档）
2.代码分析，使用反射
3.编译检查，可以让编译器实现基本的编译检查

基本内置注解

@Override
它的作用是对覆盖超类中方法的方法进行标记，如果被标记的方法并没有实际覆盖超类中的方法，则编译器会发出错误警告。

@Deprecated
它的作用是对不应该再使用的方法添加注解，当编程人员使用这些方法时，将会在编译时显示提示信息，它与javadoc里的@deprecated标记有相同的功能，准确的说，它还不如javadoc @deprecated，因为它不支持参数

以及@SuppressWarnings 警告信息注解等

在使用dagger2框架时也用用到注解，下面试dagger2使用到的注解

• @Inject 带有此注解的属性或构造方法将参与到依赖注入中，Dagger2会实例化有此注解的类
• @Module 带有此注解的类，用来提供依赖，里面定义一些用@Provides注解的以provide开头的方法，这些方法就是所提供的依赖，Dagger2会在该类中寻找实例化某个类所需要的依赖。
@Component 用来将@Inject和@Module联系起来的桥梁，从@Module中获取依赖并将依赖注入给@Inject

#### 反射是什么？什么时候用反射？

Java 反射是可以让我们在运行时获取类的函数、属性、父类、接口等 Class 内部信息的机制。通过反射还可以让我们在运行期实例化对象，调用方法，通过调用 get/set 方法获取变量的值，即使方法或属性是私有的的也可以通过反射的形式调用。

如果想调用一个类的私有属性或者私有方法，就可以用反射来实现。

#### 泛型使用在什么场景，你有写过使用泛型的代码吗？
Java1.5引入了泛型，所有的集合接口和实现都大量地使用它。泛型允许我们为集合提供一个可以容纳的对象类型，因此，如果你添加其它类型的任何元素，它会在编译时报错。这避免了在运行时出现ClassCastException，因为你将会在编译时得到报错信息。泛型也使得代码整洁，我们不需要使用显式转换和instanceOf操作符。它也给运行时带来好处，因为不会产生类型检查的字节码指令。
最近本的泛型代码 `List<String> l = new ArrayList();`

#### 异常有几种类型，OOM 属于哪种？catch finally 执行顺序？
异常分为三种：

• 检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。
• 运行时异常： 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。
错误： 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。

oom属于运行时异常

如果在try{}中捕获相应的异常，中断当前代码的执行，转而去执行catch{}中的内容， 最后去执行
finally{}中方法，一般来说finally中的方法都是会被执行的，其中finally中很大程度上用于资源的释放。

#### 集合你一般使用哪些？列表、哈希表都有哪些实现，优劣清楚吗？
最经常使用的是ArrayList，或者要求使用没用重合元素的集合时使用HashSet，在配合handler使用时也会用到WeakHashMap,WeakHashMap 的工作与正常的 HashMap 类似，但是使用弱引用作为 key，意思就是当 key 对象没有任何引用时，key/value 将会被回收。

#### IO 你一般怎么用？

一般在读取或者存储文件时使用IO

#### String 为什么不可变，与 StringBuilder StringBuffer 区别

String是字符串常量,final修饰,所以不可变;
StringBuffer字符串变量(线程安全); 
StringBuilder 字符串变量(线程不安全)；

#### 枚举各种使用场景各种使用场景

 枚举是用来存放一组固定的常量。枚举在我们项目使用的主要地方是订单状态，我们不同业务类型使用的是共同的订单状态，如未支付，已付款等。这个时候可以定义枚举，来方便大家一起使用。
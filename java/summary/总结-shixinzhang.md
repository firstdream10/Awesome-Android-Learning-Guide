2017年11月4日星期六

[TOC]

## 1.你创建一个类的时候，什么时候选择类、内部类、静态内部类、匿名内部类？设计框架时该如何选择？

- 有很多属性或者方法的时候选择类
- 需要限制特定范围的类时创建内部类，这个类可以是 public 也可以是 private，取决于是否要暴露给外部
- 静态内部类一般都用于直接当普通类使用，只不过有一个层级关系，让使用者了解这个类属于哪个类
- 匿名内部类一般用于回调了

设计框架时考虑依赖关系和职责分离，将特定职责的代码放到某一个或者多个关联的类中，职责有关联的，如果依赖外部类，可以用内部类；否则就用静态内部类。
## 2.你什么时候会创建一个抽象类，为什么不用接口？设计框架时该如何选择？

- 在需要抽离基础功能，同时定制规范时，会创建抽象方法，从而创建抽象类；
- 如果没有非抽象方法的话，使用接口和抽象类区别不大

设计框架时，能用接口表示的尽量用接口，毕竟 Java 是单继承，继承关系是强侵入；使用抽象类定义规范时，尽量只在抽象类中定义通用的，如果某个方法不是所有类都要用到，就不放到抽象类中，可以放到一个接口中，然后让需要使用的子类实现即可，避免强制实现不需要的方法。


## 3.类的成员变量修饰符有哪些？ public protected private 怎么选，什么时候用 final 修饰，什么时候会用 static 的？

成员变量修饰符有：

- 访问权限控制符：public, protected, private
- 限制只能有一个实例的：static
- 不允许修改的：final
- 不会被序列化：transient
- 线程共享数据的一致性：volatile
- 注解

访问权限控制符的范围大家都清楚：

- 一般封装过的、稳定的、不会随便修改的方法/成员变量，可以设置为 ``public``，供所有人访问
- 默认的包范围权限，允许一个包内访问，也和 public 差不多，在基本不会改变的情况下才使用
- 父类仅允许子类访问、修改的，可以设置为 ``protected``
- 类内部的成员变量、方法，设置为 ``private``，目的是不向外、子类暴露，随时有修改的可能

``final`` 可以修饰类、方法、变量：

- 修饰类的话一般表示这个类是唯一的、不允许被继承，如工具类、基础数据类型包装类
- 修饰方法表示这个方法不允许被子类重写，也是为了保证稳定性，避免重写后导致其他问题
- 修饰变量表示这个变量一旦初始化后就不会修改，一般用于在回调或者多线程中使用，表示不可变性

可以看到，``final`` 的三种用途，在某种程度上来说都是为了保证稳定、安全性。

``static`` 可以修饰内部类类、方法、变量：

- 修饰内部类表示静态内部类，和外部类同一层次的存在，无法直接访问外部类的变量，调用时才加载，即“懒加载”
- 修饰方法表示静态方法，可以直接通过类名.方法访问，一般用于工厂方法或者工具类
- 修饰变量表示静态变量，可以直接通过类名.变量访问，一般结合静态方法使用，调用时加载

静态变量都存储在方法区，所有线程都可以访问。

> 静态类、成员、方法初始化顺序忘记了...

## 4.什么时候会发生自动装箱拆箱？有什么需要注意的吗？

装箱：基本类型转成对应的包装类型；拆箱是反过来的过程。

自动装箱拆箱是 JDK 1.5 以后出现的，在进行基本类型和包装类混合操作的时候，编译器自动帮我们完成了类型转换的过程，称为“自动装箱拆箱”。

装箱拆箱的实质是调用包装类的 ``valueOf()`` 和 ``XXValue()`` 方法，所以应该注意出现空指针，即在调用可能出现自动装箱的方法前检查是否为空。

另外在一些集合里，如果持有的类型是包装类，在添加时会进行自动装箱，在循环里如果进行大量的添加删除操作的话，会产生很多额外的包装对象，对性能有影响。


## 5.注解是什么？有几种类型？什么时候用注解？

注解是一种修饰，对代码的修饰。

有三种类型：

1. 源码描述
2. 编译时注解
3. 运行时注解

在方便代码提示时可以用第一种；编译时生成代码时，可以用第二种；运行时获取注解信息，结合反射的，使用第三种。

## 6.反射是什么？什么时候用反射？

反射是在运行时动态获取类信息、创建新类和修改已有代码信息等操作。

在我们想要访问、修改第三方代码中不可修改的成员变量或者 hook 代码时，可以使用反射，它可以跳过访问权限的控制，进行一些偷梁换柱的操作。

## 7.泛型使用在什么场景，你有写过使用泛型的代码吗？

泛型表示要操作的内容类型不确定，本质上也是一个语法糖，在编译时存在，运行时就擦除了。

默认擦除为 Object 类型，我们可以为某个泛型指定上边界和下边界，方便擦除到这个范围。

一般用于集合、工具类。我在工具类等操作通用类型的方法里用过。

## 8.异常有几种类型，OOM 属于哪种？

两种，Error 和 Exception，他们都继承自 ``Throwable``。

Error 表示虚拟机、系统的异常，无法修复，但我们可以避免，比如 OutOfMemory(内存溢出) 和 StackOverFlow(调用栈溢出)，都可以在编码时注意着点；
Exception 表示代码异常，有运行时异常和受检异常两种，受检异常是指必须在编译时就进行处理，比如 IOException；
运行时异常有 ArrayIndexOutOfBoundsException 等，在程序跑起来时才知道，无法检测。

我们在日常开发中，一般在底层类中需要尽量避免 try-catch，因为这将导致代码的异常无法向上传递，很可能会导致状态的缺失，应该将异常派出去，让调用方进行合适的处理，针对异常情况制定紧急方案，而不是对异常毫不知情。

## 9.集合你一般使用哪些？列表、哈希表都有哪些实现，优劣清楚吗？

集合一般使用的是列表和哈希表，在使用时持有基类对象引用，实际上根据不同需求指向不同的实现，在修改时成本也比较小。

列表有数组实现和链表实现，数组实现就是随机访问快，但缺点是需要制定容量，否则多了就需要扩容，内存复制，有额外成本；
链表是没有容量限制，缺点是不支持随机访问，访问时只能按顺序遍历。

哈希表有无序、访问时间复杂度为 O(1) 的 HashMap，访问效率最高；也有有序的 TreeMap，但访问效率低一些；
LinkedHashMap 介于两者之间，既有序，访问效率也可以。

一般在使用集合时，需要考虑清楚他们各自的特点，结合使用场景选择空间、时间复杂度都最低的。

## 10.IO 你一般怎么用？

IO 一般在网络通信、文件操作中使用，一般都是通过字节流 InputStream 读取，然后使用 BufferInputStream 或者 BufferReader 等装饰类型的有缓存的类进行读取，加快效率。


## 11.String 相关

String 是经常使用的类型，常用的字符串操作方法都比较熟悉，需要注意的是它的字符串常量池相关，如果一个字符串声明时是常量，那它会先去常量池看有没有现成的，有就直接指向常量池中的对象，否则新建一个，放到常量池里。

另外它底层是一个 final 的字符数组实现，final 导致它声明后就无法修改，如果想要修改，会创建一个新的对象，这在循环里需要注意，如果使用大量的 "+" 来拼接字符串，会创建额外的多余对象，有顺损性能。

